<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2018-08-09 四 20:52 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>第三十三课程 Disjoint Set</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="yiddishkop" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="/home/yiddi/git_repos/YIDDI_org_export_theme/theme/org-nav-theme_cache.css" >
<script src="https://hypothes.is/embed.js" async></script>
<script type="application/json" class="js-hypothesis-config">
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2018 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">第三十三课程 Disjoint Set</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org96f5bd9">1. What is disjoint set</a></li>
<li><a href="#org53f26fa">2. List-Based Disjoint Sets and the Quick-Find Algorithm</a></li>
<li><a href="#org1f0bdab">3. Tree-Based Disjoint Sets and the Quick-Union Algorithm</a>
<ul>
<li><a href="#org6a8c293">3.1. Basic union() and find()</a></li>
<li><a href="#org2de7de7">3.2. 2 ways to speed up find()</a></li>
<li><a href="#org90fc8aa">3.3. Implementing Quick-Union with an Array</a>
<ul>
<li><a href="#orgcedb159">3.3.1. union-by-size</a></li>
<li><a href="#orge84544a">3.3.2. Path Compression</a></li>
<li><a href="#orge47c0f9">3.3.3. Naming Sets</a></li>
<li><a href="#orgae87b79">3.3.4. Running Time of Quick-Union</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>


<div id="org96f5bd9" class="outline-2">
<h2 id="org96f5bd9"><span class="section-number-2">1</span> What is disjoint set</h2>
<div class="outline-text-2" id="text-1">
<p>
A <span class="underline">disjoint_sets</span> data structure represents a collection of sets that are
<span class="underline">disjoint</span>: that is, no item is found in more than one set. The collection of
disjoint sets is called a <span class="underline">partition</span>, because the items are partitioned among
the sets.
</p>

<p>
Moreover, we work with a <span class="underline">universe</span> of items. The universe is made up of all of
the items that can be a member of a set. Every item is a member of exactly one
set.
</p>

<p>
For example, suppose the items in our universe are corporations that still
exist today or were acquired by other corporations.  Our sets are corporations
that still exist under their own name.  For instance, "Microsoft,"
"Forethought," and "Web TV" are all members of the "Microsoft" set.
</p>

<p>
We will limit ourselves to two operations.  The first is called a <span class="underline">union</span>
operation, in which we merge two sets into one.  The second is called a <span class="underline">find</span>
query, in which we ask a question like, "What corporation does Web TV belong to
today?"  More generally, a "find" query takes an item and tells us which set it
is in.  We will not support operations that break a set up into two or more
sets (not quickly, anyway).  Data structures designed to support these
operations are called <span class="underline">partition</span> or <span class="underline">union/find</span> data structures.
</p>

<p>
Applications of union/find data structures include maze generation (which
you'll do in Homework 9) and Kruskal's algorithm for computing the minimum
spanning tree of a graph (which you'll implement in Project 3).
</p>

<p>
Union/find data structures begin with every item in a separate set.
</p>

<pre class="example">
-------------- ------------ -------- ------------------- -------- -----------
|Piedmont Air| |Empire Air| |US Air| |Pacific Southwest| |Web TV| |Microsoft|
-------------- ------------ -------- ------------------- -------- -----------
</pre>

<p>
The query "find(Empire Air)" returns "Empire Air".  Suppose we take the union
of Piedmont Air and Empire Air and called the resulting corporation Piedmont
Air.  Similarly, we unite Microsoft with Web TV and US Air with Pacific SW.
</p>

<pre class="example">
-------------- ------------------- -----------
|Piedmont Air| |      US Air     | |Microsoft|
| Empire Air | |Pacific Southwest| | Web TV  |
-------------- ------------------- -----------
</pre>

<p>
The query "find(Empire Air)" now returns "Piedmont Air".  Suppose we further
unite US Air with Piedmont Air.
</p>

<pre class="example">
-------------------------------- -----------
|      US Air      Piedmont Air| |Microsoft|
|Pacific Southwest  Empire Air | | Web TV  |
-------------------------------- -----------
</pre>

<p>
The query "find(Empire Air)" now returns "US Air".  When Microsoft takes over
US Air, everything will be in one set and no further mergers will be possible.

</p>
</div>
</div>
<div id="org53f26fa" class="outline-2">
<h2 id="org53f26fa"><span class="section-number-2">2</span> List-Based Disjoint Sets and the Quick-Find Algorithm</h2>
<div class="outline-text-2" id="text-2">
<p>
The obvious data structure for disjoint sets looks like this.
</p>
<ul class="org-ul">
<li>Each set references a list of the items in that set.</li>
<li>Each item references the set that contains it.</li>
</ul>

<p>
<code>find()</code> 是 O(1)的原因是，each item knows what set it's in; With this data
structure, find operations take O(1) time; hence, we say that list-based
disjoint sets use the <span class="underline">quick-find</span> algorithm.
</p>

<p>
However, union operations are slow, because when two sets are united, we must
walk through one set and relabel all the items so that they reference the other
set.
</p>

<p>
Time prevents us from analyzing this algorithm in detail (but see Goodrich and
Tamassia, Section 11.4.3).  Instead, let's move on to the less obvious but
flatly superior <span class="underline">quick-union</span> algorithm.
</p>
</div>
</div>

<div id="org1f0bdab" class="outline-2">
<h2 id="org1f0bdab"><span class="section-number-2">3</span> Tree-Based Disjoint Sets and the Quick-Union Algorithm</h2>
<div class="outline-text-2" id="text-3">
</div>
<div id="org6a8c293" class="outline-3">
<h3 id="org6a8c293"><span class="section-number-3">3.1</span> Basic union() and find()</h3>
<div class="outline-text-3" id="text-3-1">
<p>
In tree-based disjoint sets, union operations take O(1) time, but find
operations are slower.  However, for any sequence of union and find operations,
the quick-union algorithm is faster overall than the quick-find algorithm.
</p>

<p>
tree-based 的 tree 不是二叉树，而是一棵普通树。
</p>

<p>
To support fast unions, each set is stored as a general tree.
</p>

<p>
The quick-union data structure comprises a <span class="underline">forest</span> (a collection of trees), in
which each item is initially the root of its own tree; then trees are merged by
union operations. The quick-union data structure is simpler than the general
tree structures you have studied so far, because there are no child or sibling
references. Every node knows only its parent, and you can only walk up the tree.
The true identity of each set is recorded at its root.
</p>

<p>
Union is a simple O(1) time operation:
</p>

<p>
we simply make the root of one set become a child of the root of the other set.
For example, when we form the union of US Air and Piedmont Air:
</p>

<pre class="example">
                                                          US Air
Piedmont Air        US Air                                 ^  ^
      ^               ^                                    |  |
      |               |                         Piedmont Air  Pacific Southwest
 Empire Air   Pacific Southwest      ====&gt;            ^
                                                      |
                                                 Empire Air
</pre>

<p>
US Air becomes a set containing four members.  However, finding the set to
which a given item belongs is not a constant-time operation.
</p>

<p>
The find operation is performed by following the chain of parent references
from an item to the root of its tree.  For example, find(Empire Air) will
follow the path of references until it reaches US Air.  The cost of this
operation is proportional to the item's depth in the tree.
</p>

<p>
因为一直是把小的树，往更大的树上嫁接，所以三层最少也需要 8 个 nodes。
</p>
</div>
</div>

<div id="org2de7de7" class="outline-3">
<h3 id="org2de7de7"><span class="section-number-3">3.2</span> 2 ways to speed up find()</h3>
<div class="outline-text-3" id="text-3-2">
<p>
we'll consider two optimizations that make finds faster.
</p>

<ul class="org-ul">
<li>One strategy, called <span class="underline">union-by-size</span>, helps the union operation to build
shorter trees. 简单说就是把小树往大树上嫁接
<ul class="org-ul">
<li>At each root, we record the size of its tree (i.e. the number of nodes in the tree).</li>
<li>When we unite two trees, we make the <span class="underline">smaller</span> tree a <span class="underline">subtree</span> of the larger one (breaking ties arbitrarily).</li>
</ul></li>
<li>The second strategy, called <span class="underline">path compression</span>, gives the find operation the power to shorten trees.
<ul class="org-ul">
<li>when find() some node, we will fix its ref of parent to root</li>
<li>then,next time find this node will only cost O(1) time</li>
<li>这个思想特别像 Splay tree</li>
</ul></li>
</ul>
<pre class="example">
                    ___________
node -&gt; visited! -&gt; |item| .--+---X---&gt; parent
                    -------+---
                           +----------&gt; root
</pre>
<p>

</p>
</div>
</div>
<div id="org90fc8aa" class="outline-3">
<h3 id="org90fc8aa"><span class="section-number-3">3.3</span> Implementing Quick-Union with an Array</h3>
<div class="outline-text-3" id="text-3-3">
<p>
Suppose the items are non-negative integers, numbered from zero.  We'll use an
array to record the parent of each item.
</p>

<ul class="org-ul">
<li>If an item has no parent, we'll record the size of its tree.</li>
<li>To distinguish it from a parent reference, we'll record the size s as the negative number -s.</li>
<li><p>
Initially, every item is the root of its own tree, so we set every array element to -1.
</p>

<pre class="example">
                        -------------------------------
                        |-1|-1|-1|-1|-1|-1|-1|-1|-1|-1|
                        -------------------------------
                          0  1  2  3  4  5  6  7  8  9

The forest illustrated at left below is represented by the array at right.

          8        1        2                  -------------------------------
         / \      /|\                          | 1|-4|-1| 8| 5| 8| 1| 3|-5| 1|
        5   3    9 0 6                         -------------------------------
        |   |                                    0  1  2  3  4  5  6  7  8  9
        4   7
</pre></li>
</ul>

<p>
This is a slightly kludgy way to implement tree-based disjoint sets, but it's
fast (in terms of the constant hidden in the asymptotic notation).
</p>
</div>
<div id="orgcedb159" class="outline-4">
<h4 id="orgcedb159"><span class="section-number-4">3.3.1</span> union-by-size</h4>
<div class="outline-text-4" id="text-3-3-1">
<p>
Let root1 and root2 be two items that are roots of their respective trees.
Here is code for the union operation with the union-by-size strategy.
</p>

<div class="org-src-container">
<pre class="src src-java" id="org1e7ff88"><span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #ce537a; font-weight: bold;">void</span> <span style="color: #bc6ec5; font-weight: bold;">union</span>(<span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">root1</span>, <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">root2</span>) {   (ref:union(<span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">root1</span>, <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">root2</span>))
  <span style="color: #4f97d7; font-weight: bold;">if</span> (array[root2] &lt; array[root1]) {                 <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">root2 has larger tree</span>
    array[root2] += array[root1];        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">update # of items in root2's tree</span>
    array[root1] = root2;                       <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">make root2 parent of root1</span>
  } <span style="color: #4f97d7; font-weight: bold;">else</span> {                                  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">root1 has equal or larger tree</span>
    array[root1] += array[root2];        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">update # of items in root1's tree</span>
    array[root2] = root1;                       <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">make root1 parent of root2</span>
  }
}
</pre>
</div>

<p>
this code is just keeped short for class ,is not a very well encapsulated union
operation though, and the reason why is that a good union operation would hide
the fact that certain node are roots of the tree, because really a disjoint set
data structure, all the external caller is really supposed to know is that this
is a set, they're <span class="underline">not supposed to know that one of those items is special</span>
because that's an implementation detail and so really you'd like to hide that
implementation detail it's what you really want to do is you really want to
start this(<a href="#coderef-union(int root1, int root2)" class="coderef" onmouseover="CodeHighlightOn(this, 'coderef-union(int root1, int root2)');" onmouseout="CodeHighlightOff(this, 'coderef-union(int root1, int root2)');">union</a>) by <span class="underline">doing a find on each of these two nodes</span> finding the roots
of the two trees and then doing the union.
</p>

<p>
注意这个 union 和 find 操作对解决之前的 minimum spanning tree ,一个 weighted 图的最小生成树问题:
</p>

<p>
<b>minimum spanning tree</b>:
</p>
<pre class="example">
1. 遍历 E，不断从 E 中选择 weighted 最小的线段(v,w)
2. 如果 v，w 联通(可以通过判断两者各自所属 set 是否是一个 set，find 函数，比如 list-based disjoint data structue,每个 node
   都存了自己的 root-node 索引，就可以直接 find v 和 w 的 root-node 看是否相同，不同则说明两者不是一个 set，也就不联通)
   则忽略，如果不联通，则 union(set(v),set(w))(这个操作在 list-based disjoint 上就是把数目更小的 set 的每个 node 的
   root-node 索引设置成数目更多的 set 的 root-node 即可),然后将 v-w 存入结果中（结果应该是 v-w, g-h, h-w, v-z...）这个样子。
3. 一旦某个 set 包含了所有 node（这在 list-based disjoint 表现为所有 node 的 root-node 的 reference 都一样）就可以停止遍历 E 了。
</pre>

<p>
<b>回忆 graph 问题的两种 traversal 方法</b> ：
</p>
<pre class="example">
1. DFS： 可以用 recurvise 方式实现，
   1) set all node's 'visited' value false
   2) choose a start-node randomly
   3) visit(start-node)
   4) for every node connected with start-node ---- simply search (v,w) in E
   5) if visited, ignore; else, _recursively_ DFS(this node)
2. BFS: 无法用 recursive，而是用 queue
   1. set all node's visited value to false
   2. choose a start-node randomly
   3. visit(start-node), enqueue(start-node)
   4. _while_ queue is not empty:
      1. current-parent-node = dequeue()
      2. _for_ every node connected with start-node
         1. if visited,ignore; else,visited(this node), and enqueue(this node)
</pre>

<p>
BFS 可以用在 minimum spanning tree 和 shorttest path 问题中;
</p>
</div>
</div>

<div id="orge84544a" class="outline-4">
<h4 id="orge84544a"><span class="section-number-4">3.3.2</span> Path Compression</h4>
<div class="outline-text-4" id="text-3-3-2">
<p>
The find() method is equally simple, but we need one more trick to obtain the
best possible speed.  Suppose a sequence of union operations creates a tall
tree, and we perform find() repeatedly on its deepest leaf.  Each time we
perform find(), we walk up the tree from leaf to root, perhaps at considerable
expense.  When we perform find() the first time, why not move the leaf up the
tree so that it becomes a child of the root?  That way, next time we perform
find() on the same leaf, it will run much more quickly.  Furthermore, why not
do the same for <span class="underline">every</span> node we encounter as we walk up to the root?
</p>

<p>
we do it in a lazy way which is we don't do it until there's a reason, like
if no one ever does a find operation on one node,then why waste time fixing its
pointer.
</p>

<pre class="example">
      0
     /|\                                      _ 0 _
    1 2 3                                    / /|\ \
   /|\             ==find(7)==&gt;             7 4 1 2 3
  4 5 6                                      /| |\
 /|\                                        8 9 5 6
7 8 9
</pre>

<p>
In the example above, find(7) walks up the tree from 7, discovers that 0 is the
root, and then makes 0 be the parent of 4 and 7, so that future find operations
on 4, 7, or their descendants will be faster.  This technique is called
<span class="underline">path_compression</span>.
</p>

<p>
Let x be an item whose set we wish to identify.  Here is code for find, which
returns the identity of the item at the root of the tree.
</p>

<div class="org-src-container">
<pre class="src src-java" id="orgf98d143"><span style="color: #4f97d7; font-weight: bold;">public</span> <span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #bc6ec5; font-weight: bold;">find</span>(<span style="color: #ce537a; font-weight: bold;">int</span> <span style="color: #7590db;">x</span>) {
  <span style="color: #4f97d7; font-weight: bold;">if</span> (array[x] &lt; <span style="color: #a45bad;">0</span>) {
    <span style="color: #4f97d7; font-weight: bold;">return</span> x;                         <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">x is the root of the tree; return it</span>
  } <span style="color: #4f97d7; font-weight: bold;">else</span> {
    <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Find out who the root is; compress path by making the root x's parent</span>
    array[x] = find(array[x]);        <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">in tree-based data structure, array[x] store the parent of x</span>
                                      <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">this will,at last make root store in array[x]</span>
    <span style="color: #4f97d7; font-weight: bold;">return</span> array[x];                  <span style="color: #2aa1ae; background-color: #292e34;">// </span><span style="color: #2aa1ae; background-color: #292e34;">Return the root</span>
  }
}
</pre>
</div>
</div>
</div>

<div id="orge47c0f9" class="outline-4">
<h4 id="orge47c0f9"><span class="section-number-4">3.3.3</span> Naming Sets</h4>
<div class="outline-text-4" id="text-3-3-3">
<p>
Union-by-size means that if Microsoft acquires US Air, US Air will be the root
of the tree(Microsoft'tree is smaller than US Air's), even though the new
conglomorate might still be called Microsoft.
</p>

<p>
What if we want some control over the names of the sets when we perform union()
operations?
</p>

<p>
The solution is to maintain <span class="underline">an additional array</span> that maps root items to set
names (and perhaps vice versa, depending on the application's needs). For
instance, the array "name" might map 0(where US Air stored) to Microsoft.
</p>

<p>
这个意思大概是维护另一个数组&#x2013;name[]，数组下标与 root 节点的在另一数组的下标相同，但存储的是该 set 的名字，比如这里的 microsoft：
</p>

<pre class="example">
_______________________________
| US Air | xxxx | xxxx | xxxx |
-------------------------------
    0       1       2      3
_______________________________
| microsoft |   |   |   |
-------------------------------
    0
</pre>
<p>
We must modify the union() method so that when it unites two sets, it assigns
the union an appropriate name.
</p>

<p>
For many applications, however, we don't care about the name of a set at all; we
only want to know if two items x and y are in the same set. This is true in both
Homework 9 and Project 3. You only need to run find(x), run find(y), and check
if the two roots are the same.
</p>
</div>
</div>

<div id="orgae87b79" class="outline-4">
<h4 id="orgae87b79"><span class="section-number-4">3.3.4</span> Running Time of Quick-Union</h4>
<div class="outline-text-4" id="text-3-3-4">
<ul class="org-ul">
<li><code>Union</code>: <span class="underline">theta(1)</span></li>
</ul>


<p>
Union operations obviously take Theta(1) time. (Look at the code&#x2013;no loops or
recursion.)
</p>

<ul class="org-ul">
<li><code>Find</code>: <span class="underline">theta(log u)</span></li>
</ul>


<p>
If we use union-by-size, a single find operation can take Theta(log u)
worst-case time, where u is the number of union operations that took place
prior to the find. The only way to increase the height of the tree by one is
to at least double its size from the minimum possible size.
</p>

<p>
就像之前如果 find()一个叶子节点，需要从叶子-&gt;父节点-&gt;&#x2026;-&gt;root。所以这又是一个树的深度问题，所以树的深度就是 O(log(n))
</p>

<ul class="org-ul">
<li><code>Average running time of find() by path compression</code>: <span class="underline">Constant</span></li>
</ul>


<p>
Path compression does not improve this worst-case time, but
it improves the <span class="underline">average</span> running time substantially&#x2013;although a find operation
can take Theta(log u) time, path compression will make that operation fast if
you do it again.  The average running time of find and union operations in the
quick-union data structure(注意，对于 disajoint 数据结构：quick-union 就是指 tree-based,
quick-find 就是 list-based) is so close to a constant that it's hardly worth
mentioning that, in a rigorous asymptotic sense, it's slightly slower.
</p>

<ul class="org-ul">
<li><code>quick-Union Total</code>: theta(u+f*alpha(f+u,u)), <span class="underline">constant</span> approximately.</li>
</ul>


<p>
The bottom line: a sequence of f find and u union operations (in any order and
possibly interleaved) takes Theta(u + f alpha(f + u, u)) time in the worst
case. alpha is an extremely slowly-growing function known as the <span class="underline">inverse</span>
<span class="underline">Ackermann_function</span>.
</p>

<p>
When I say "extremely slowly-growing function", I mean "comically slowly-
growing function."  The inverse Ackermann function is never larger than 4 for
any values of f and u you could ever use (though it does grow arbitrarily
large&#x2013;for unimaginably gigantic values of f and u).  Hence, for all practical
purposes (but not on the Final Exam), you should think of quick-union as having
find operations that run, on average, in constant time.
</p>
</div>
</div>
</div>
</div>
</div>
</body>
</html>
