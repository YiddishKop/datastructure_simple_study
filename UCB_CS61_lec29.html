<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2018-08-09 四 21:14 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>第二十九课 Graph-BFS</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="yiddishkop" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="/home/yiddi/git_repos/YIDDI_org_export_theme/theme/org-nav-theme_cache.css" >
<script src="https://hypothes.is/embed.js" async></script>
<script type="application/json" class="js-hypothesis-config">
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2018 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">第二十九课 Graph-BFS</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orge0dce4d">1. GRAPHS (BFS)</a></li>
<li><a href="#org7708422">2. Weighted Graphs</a></li>
<li><a href="#org9b3f66d">3. [greedy algo]Kruskal's Algorithm for Finding Mimumum Spanning Trees           </a></li>
<li><a href="#orgcfd5425">4. [greedy algo]Prim's Algo for Finding minimum spanning tree</a></li>
<li><a href="#orgd11de02">5. Shortest path tree and Distances</a></li>
</ul>
</div>
</div>


<div id="orge0dce4d" class="outline-2">
<h2 id="orge0dce4d"><span class="section-number-2">1</span> GRAPHS (BFS)</h2>
<div class="outline-text-2" id="text-1">
<p>
Breadth-first search (BFS) is a little more complicated than depth-first search,
because it's not naturally recursive. We use a <span class="underline">queue</span> so that vertices are
visited in order according to their distance from the starting vertex. BFS is a
lot like level-order tree traversal.
</p>

<pre class="example">
  public void bfs(Vertex u) {                                                   //       initial *
    for (each vertex v in V) {                                   // O(|V|) time //               |
      v.visited = false;                                                        //-+             v 访问
    }                                                                           // |             |
    u.visit(null);                            // Do some unspecified thing to u // |             v
    u.visited = true;                              // Mark the vertex u visited // |             进队:enqueue 求子
    q = new Queue();                                            // New queue... // |             |
    q.enqueue(u);                                  // ...initially containing u // |             v
    while (q is not empty) {                // With adjacency list, O(|E|) time // |  +--------&gt; 出队:dequeue 得子
      v = q.dequeue();                                                          // |  |          |
      for (each vertex w such that (v, w) is an edge in E) {                    // |  |          +-------------------------------+ queue build (for-loop)
        if (!w.visited) {                                                       // |  |          |   |-&gt;|  |-&gt;|  |-&gt;|   ......   |
          w.visit(v);                         // Do some unspecified thing to w //-+  |          v   |  v  |  v  |  v            v
          w.visited = true;                        // Mark the vertex w visited // |  |         子 1 访问 子 2 访问 子 3 访问子 4 访问       子 n 访问
          q.enqueue(w);                                                         // |  |          |  /   |  /  |  /  |            |
        }                                                                       // |  |          v /    v /   v /   v            v
      }                                                                         // |  |        进队/    进/   进/    进队         进队
    }                                                                           // |  +----------+ queue FIFO (while-loop)
  }                                                                             // | 整体就是 访问--&gt;儿子队：循环(求子-&gt;访问子-&gt;子进队)--&gt;出子-&gt;访问
                                                                                   |
                                         public class Vertex {                     |
                                           protected Vertex parent;                |
                                           protected int depth;                    |
Notice that when we visit a vertex,        protected boolean visited;              |
we pass the edge's origin vertex                                                   |
as a parameter.  This allows us to       public void visit(Vertex origin) {    &lt;---+
do a computation such as finding           this.parent = origin;
the distance of the vertex from            if (origin == null) {
the starting vertex, or finding              this.depth = 0;
the shortest path between them.            } else {
The visit() method at right                  this.depth = origin.depth + 1;
accomplishes both these tasks.             }
                                         }
                                       }
                                                                      +-4--+
                                                           forbidden  X    |
                                                                      |    |
                                                                      v  --3
                                                                    __2     \3
注意这里是如何保证每个 node 存储的都是最短路径？                          _1    \2    \3
1. 首先利用 queue 确保层层推进; 越先访问的，路径越短;                      \1   |2    |3
2. 其次利用 visited 保证每个 node's depth 只被写入一次;                *  |1   |2    |3
   所以后访问的，想改写前面 node's depth 是 forbidden 的;                /1   /2    /3
                                                                    --2     /3
                                                                        ---3
</pre>


<p>
When an edge (v, w) is traversed to visit a Vertex w, <span class="underline">the depth of w is set to</span>
<span class="underline">the depth of v plus one</span>, and v is set to become the <span class="underline">parent</span> of w.
</p>

<p>
The sequence of figures below shows BFS running on the city adjacency graph
(Albany, Kensington, Emeryville, Berkeley, Oakland, Piedmont) from last
lecture, starting from Albany.  A "V" is currently visited; a digit shows the
depth of a vertex that is marked visited; a "*" is a vertex which we try to
visit but discover has already been visited.  Underneath each figure of the
graph, I depict the queue and the current value of the variable "v" in bfs().
</p>

<pre class="example">
V-K  0-V  0-1  *-1  0-1  *-1  0-*  0-1  0-1  0-1  0-1  0-1  0-1  0-1  0-1  0-1
 \|   \|   \|   \|   \|   \|   \|   \|   \|   \|   \|   \|   \|   \|   \|   \|
E-B  E-B  E-V  E-1  E-*  E-1  E-1  V-1  2-1  2-*  2-1  *-1  2-*  2-1  2-1  2-1
|/   |/   |/   |/   |/   |/   |/   |/   |/   |/   |/   |/   |/   |/   |/   |/
O-P  O-P  O-P  O-P  O-P  O-P  O-P  O-P  V-P  2-P  *-P  2-P  2-P  2-V  *-3  2-3

===  ===  ===  ===  ===  ===  ===  ===  ===  ===  ===  ===  ===  ===  ===  ===
A    K    KB   B    B              E    EO   O    O              P
===  ===  ===  ===  ===  ===  ===  ===  ===  ===  ===  ===  ===  ===  ===  ===
     v=A  v=A  v=K  v=K  v=B  v=B  v=B  v=B  v=E  v=E  v=O  v=O  v=O  v=P

</pre>

<pre class="example">
After we finish, we can find the shortest path from any vertex to the     0&lt;--1
starting vertex by following the parent pointers (right).  These           ^
pointers form a tree rooted at the starting vertex.  Note that they         \
point in the direction _opposite_ the search direction that got us there.    \
                                                                          2--&gt;1
Why does this work?  The starting vertex is enqueued first, then all the     ^
vertices at a distance of 1 from the start, then all the vertices at a      /
distance of 2, and so on.  Why?  When the starting vertex is dequeued,     /
all the vertices at a distance of 1 are enqueued, but no other vertex     2&lt;--3
is.  When the depth-1 vertices are dequeued and processed, all the
vertices at a distance of 2 are enqueued, because every vertex at a distance of
2 must be reachable by a single edge from some vertex at a distance of 1.  No
other vertex is enqueued, because every vertex at a distance less than 2 has
been marked, and every vertex at a distance greater than 2 is not reachable by
a single edge from some vertex at a distance of 1.

</pre>

<p>
<b>Recommendation</b>: pull out a piece of paper, draw a graph and a program stack,
and simulate BFS, with you acting as the computer and executing bfs() line by
line. You will understand it much better after taking the time to do this.
</p>

<p>
BFS, like DFS, runs in <code>O(|V| + |E|)</code> time if you use an adjacency list;
<code>O(|V|^2)</code> time if you use an adjacency matrix.
</p>
</div>
</div>

<div id="org7708422" class="outline-2">
<h2 id="org7708422"><span class="section-number-2">2</span> Weighted Graphs</h2>
<div class="outline-text-2" id="text-2">
<p>
A weighted graph is a graph in which each edge is labeled with a numerical
weight. A weight might express the distance between two nodes, the cost of
moving from one to the other, the resistance between two points in an electrical
circuit, or many other things.
</p>

<p>
In an adjacency matrix, each weight is stored in the matrix.  Whereas an
</p>
<ul class="org-ul">
<li>unweighted graph uses an array of booleans;</li>
<li>weighted graph uses an array of ints, doubles, or some other numerical type.</li>
</ul>

<p>
Edges missing from the graph can
be represented by a special number like Integer.MIN_VALUE, at the cost of
declaring that number invalid as an edge weight.  (If you want to permit every
int to be a valid edge weight, you might use an additional array of booleans
as well.)
</p>

<p>
In an adjacency list, recall that each edge is represented by a listnode.  Each
listnode must be enlarged to include a weight, in addition to the reference to
the destination vertex.  (If you're using an array implementation of lists,
you'll need two separate arrays:  one for weights, and one for destinations.)
</p>

<p>
There are two particularly common problems involving weighted graphs.
</p>

<p>
One is the <span class="underline">shortest_path_problem</span>.
Suppose a graph represents a highway map,
and each road is labeled with the amount of time it takes to drive from one
interchange to the next. What's the fastest way to drive from Berkeley to Los
Angeles? A shortest path algorithm will tell us. You'll learn several of these
algorithms if you take CS 170.
</p>

<p>
The second problem is constructing a <span class="underline">minimum_spanning_tree</span>.
Suppose that you're wiring a house for electricity. Each node of the graph
represents an outlet, or the source of electricity. Every outlet needs to be
connected to the source, but not necessarily directly&#x2013;possibly routed via
another outlet. The edges of the graph are labeled with the length of wire
you'll need to connect one node to another. How do you connect all the nodes
together with the shortest length of wire?

</p>
</div>
</div>
<div id="org9b3f66d" class="outline-2">
<h2 id="org9b3f66d"><span class="section-number-2">3</span> [greedy algo]Kruskal's Algorithm for Finding Mimumum Spanning Trees           <a id="org88477e7"></a></h2>
<div class="outline-text-2" id="text-3">
<p>
Let <code>G = (V, E)</code> be an undirected graph. A <span class="underline">spanning_tree</span> <code>T = (V, F)</code> of G is
a graph containing the same vertices as G, <span class="underline">and <code>|V| - 1</code> edges of G that form a
tree</span>. (Hence, there is exactly one path between any two vertices of T.)
</p>

<p>
If G is not connected, it has no spanning tree, but we can instead compute a
<span class="underline">spanning_forest</span>, or collection of trees, having one tree for each connected
component of G.
</p>

<p>
If G is weighted, then a <span class="underline">minimum spanning tree</span> T of G is a spanning tree of G
whose total weight (summed over all edges of T) is minimal. In other words, no
other spanning tree of G has a smaller total weight.
</p>

<p>
Kruskal's algorithm computes the mimimum spanning tree of G as follows.
</p>

<pre class="example">
[1]  Create a new graph T with the same vertices as G, but no edges (yet).
[2]  Make a list of all the edges in G.
[3]  Sort the edges by weight, from least to greatest.
[4]  Iterate through the edges in sorted order.
     For each edge (u, w):
[4a]   If u and w are not connected by a path in T, add (u, w) to T.
这个意思就是由图，生成树(没有环路),然后确保整棵树的 weight 最小。
</pre>


<p>
Because this algorithm never adds (u, w) if some path already connects u and w,
T is guaranteed to be a tree (if G is connected) or a forest (if G is not).
</p>

<p>
Why is T a minimum spanning tree in the end?
</p>

<p>
Suppose the algorithm is considering adding an edge (u, w) to T, and there is
not yet a path connecting u to w. Let U be the set of vertices in T that are
connected (so far) to u, and let W be a set containing all the other vertices,
including w. Let the <span class="underline">bridge_edges</span> be any edges in G that have one end vertex
in U and one end vertex in W. Any spanning tree must contain at least one of
these bridge edges. As long as we choose a bridge edge with the least weight, we
are safe. (There may be several bridge edges with the same least weight, in
which case it doesn't matter which one we choose.)
</p>

<pre class="example">
+-------------+-----------------+-------------+  T
|             |                 |             |
| U           |    W            | other       |
|             |                 |             |
+---^---+-----+---------^--+----+-------------+
    |   |               |  |
    |   |connected      |  |connected
    |   |               |  |
    |   u               |  w
    |                   |
----+-------------------+--------------------------------------
    +---------------+   +--+                     G
                    |      |
                 ---+------+--
                (    E        )
                 -------------
</pre>

<p>
Because we go through the edges of G in order by weight, (u, w) must have the
least weight, because it's the first edge we encountered connecting U to W.
(See Goodrich and Tamassia page 649 for a proof that choosing the bridge edge
with least weight is always the right thing to do.)
</p>

<p>
What is the running time of Kruskal's algorithm?
</p>

<ol class="org-ol">
<li>step [1] and [2],running time is O(|V|)</li>
<li>step [3],as we'll discover in the next two lectures, sorting |E| edges takes O(|E| log |E|) time.</li>
<li>step [4a], determining whether u and w are
already connected by a path. The simplest way to do this is by doing a
<span class="underline">depth-first search</span> on T starting at u, and seeing if we visit w. But if we do
that, Kruskal's algorithm might take <span class="underline">Theta(|E| |V|))</span> time.</li>
<li>We can do better.  In Lecture 33, we'll learn how to solve that problem
quickly, so that all the iterations of [4a] together take less than <span class="underline">O(|E| log |E|)</span> time.</li>

<li>add 1~4 up:
<ul class="org-ul">
<li>If we use an adjacency list, the running time is in O(|V| + |E| log |E|).
But |E| &lt; |V|^2, so log |E| &lt; 2 log |V|.
Therefore, Kruskal's algorithm runs in O(|V| + |E| log |V|) time.</li>
<li>If we use an adjacency matrix, the running time is in O(|V|^2 + |E| log |E|),
because it takes Theta(|V|^2) time simply to make a list of all the edges.</li>
</ul></li>
</ol>
</div>
</div>
<div id="orgcfd5425" class="outline-2">
<h2 id="orgcfd5425"><span class="section-number-2">4</span> [greedy algo]Prim's Algo for Finding minimum spanning tree</h2>
<div class="outline-text-2" id="text-4">
<p>
minimum spanning tree 肯定是有 n 个节点，且有 n-1 条连接的这么个树。
</p>

<p>
greedy algo: take the smallest as you can ,and keep adding.
kruskal: let forest grow together.
prim: let edge is connected to the tree you have started to grow
let edge which is connected to the small tree that we've created.
we could have a heap that has stored all the nodes, we are going
to keep the smallest edge from that vertex to the frontier(可以理解为前线). we
keep nodes on the heap that represents our frontier.
</p>

<pre class="example">
Prime algo, just pick a node randomly as root.
need 2 arrays:
parent array, the backer is the decendence, storing the tree simply by storing the
              partent, no left, no right. parent represents the current potential finge
value array, how dose it cost to include this node into the spanning tree.
             we only change it if it do better,means an item of array will smaller.
     1 heap: candidates for the next node, 为什么需要 heap，注意 heap 的特点，可以用 O(1)的速度取出最大 or 最小值。
             这里就可以从 candidates 中取出最小值。
             heap store all nodes in it,
</pre>

<p>
running time: <code>n + nlogn + elogn</code>
</p>


<p>
注意，这里使用的是 heap + 2 arrays， 这种方法适用于稀疏矩阵。还可以使用二维矩阵， 他的复杂度最差是 O(n^2), 适合于非稀疏矩阵。
</p>
</div>
</div>
<div id="orgd11de02" class="outline-2">
<h2 id="orgd11de02"><span class="section-number-2">5</span> Shortest path tree and Distances</h2>
<div class="outline-text-2" id="text-5">
<pre class="example">
      B -----1------ F
    /   \          / |
   /     \        4  |
  2       2      /   |
 /         \    /    |
/           \  /     1
A ----1----- C       |
\          / \       |
 \        /   \      |
  1      4     3     |
   \    /       \    |
    \  /         \   |
     \/           \  |
      D -----2----- E

</pre>


<ol class="org-ol">
<li><p>
$ = infinite
</p>
<pre class="example">
                                  array Dist                   array Parent
       B -----1------ F          A|  0   |                      A| nil |
     /   \          / |          B|  $   |                      B|     |
    /     \        4  |          C|  $   |                      C|     |
   4       2      /   |          D|  $   |                      D|     |
  /         \    /    |          E|  $   |                      E|     |
 /           \  /     1          F|  $   |                      F|     |
*A ----1----- C       |
 \          / \       |
  \        /   \      |
   1      4     3     |
    \    /       \    |
     \  /         \   |
      \/           \  |
       D -----2----- E

</pre></li>

<li><p>
go from A to all nodes adjacented, record distance in Dist and parent in
Parent then, cut A off, to guarantee every node will be visited ONLY ONCE.
</p>
<pre class="example">
                                  array Dist                   array Parent
       B -----1------ F         +A|  0   |+                    +A| nil |+
     /.  \          / |          B|  4   |                      B|  A  |
    /.    \        4  |          C|  1   |                      C|  A  |
   4.      2      /   |          D|  1   |                      D|  A  |
  /.        \    /    |          E|  $   |                      E|     |
 /.          \  /     1          F|  $   |                      F|     |
*A ----1----- C       |
 \........../ \       |
  \.       /   \      |
   1.     4     3     |
    \.   /       \    |
     \. /         \   |
      \/           \  |
       D -----2----- E

</pre></li>

<li><p>
then, scan the node with smallest distance in Dist like (2) Dist[C] + CB &lt;
Dist[B], overwrite Dist[B] with 3, overwrite Parent[B] with C '$' changed
with Dist[C] + C* cut C off, if scan finish
</p>
<pre class="example">
                                  array Dist                   array Parent
       B -----1------ F         +A|  0   |+                    +A| nil |+
     /.  \.        ./ |          B|+4+,3 |                      B|+A+,C|
    /.    \.      .4  |         +C|  1   |+                    +C|  A  |+
   4.      \.    ./   |          D|  1   |                      D|  A  |
  /.        \.  ./    |          E|+$+,4 |                      E|  C  |
 /.          \../     1          F|+$+,5 |                      F|  C  |
*A ----1----- *C      |
 \........../.\.      |
  \.       /.  \.     |
   1.     4.    3.    |
    \.   /.      \.   |
     \. /.        \.  |
      \/.          \. |
       D -----2----- E

</pre></li>

<li><p>
then, scan the node smallest distance in Dist like (2) Dist[B] + BF &lt;
Dist[F], overwrite Dist[F] with 4, overwrite Parent[F] with B '$' changed
with Dist[C] + C* cut C off, if scan finish
</p>

<pre class="example">
         ............             array Dist                   array Parent
      *B -----1------ F        +A|  0      |+                 +A| nil     |+
     /.  \.        ./ |         +B|+4+,3    |+                 +B|+A+,C    |+
    /.    \.      .4  |         +C|  1      |+                 +C|  A      |+
   4.      2.    ./   |          D|  1      |                   D|  A      |
  /.        \.  ./    |          E|+$+,4    |                   E|  C      |
 /.          \../     1          F|+$+,+5+,4|                   F|+C+,B    |
*A ----1----- *C      |
 \........../.\.      |
  \.       /.  \.     |
   1.     4.    3.    |
    \.   /.      \.   |
     \. /.        \.  |
      \/.          \. |
       D -----2----- E

(*) .... loop like upper steps, at last, then you will get the shottest distance
         in Dist array and the Path follow the Parent array.
</pre></li>
</ol>
</div>
</div>
</div>
</body>
</html>
